+++

date = "2017-01-31T23:59:59+08:00"
title = "Linux设备模型小结——总线"
categories = ["技术文章"]
tags = ["Linux","内核"]
author = "月光晒谷"
author_homepage =  "http://liuao.tech"

+++


&nbsp; &nbsp; &nbsp; &nbsp;最近一直在读Linux设备模型相关的内容，包括LKD和LDD相关的章节，也在读相关的内核源码（2.6.35）。从一开始的迷迷糊糊，到现在似乎看到了一些轮廓，因为这部分对于我来说有些抽象，决定写下目前的理解作为阶段总结。

<!--more-->


&nbsp; &nbsp; &nbsp; &nbsp;Linux设备模型是从2.6版本开始抽象出来的，目的是更加方便有效地管理各种日益增多的设备。Linux设备模型是将内核和设备之间的关系通过总线的形式表示出来，这似乎是对硬件中CPU和各种外设之间相互连接总线的一种抽象，即使是那些没有通过物理总线相连的设备，Linux设备模型中也抽象出“platform bus”(平台总线)。在Linux设备模型中，一条总线是由设备和驱动两部分组成。每一个总线上的设备对应于一个硬件设备，它包含了该硬件设备相关的所有数据结构。而每一个驱动对应于硬件中一类设备的相关操作。Linux设备模型中这样的设计应该是将数据和操作尽可能的进行分离，降低数据与操作之间的耦合。设备用于描述硬件设备相关的数据，但不提供对于设备的任何操作；而驱动则只是提供相同设备的所有操作，但其操作所需要的数据都是由对应的设备提供。

![platform](http://liuao.tech/images/platform.png)

&nbsp; &nbsp; &nbsp; &nbsp;在总线、设备和驱动中，内核是通过其数据结构中的变量name进行区分的。即每个总线有唯一的name，设备和驱动的name相同，则表示设备与驱动相互匹配。由于驱动是相同类型的设备，而设备则单独指一个硬件设备，则设备中需要有一个用于表示具体设备编号的变量id。


&nbsp; &nbsp; &nbsp; &nbsp;Linux内核是支持运行时加载的，因此当有设备（驱动）添加到总线中时，总线会通过match()函数进行设备与驱动的匹配查询，当新添加的设备（驱动）有匹配的驱动（设备）时，会调用驱动中的probe()函数，进行设备的初始化相关的工作。


&nbsp; &nbsp; &nbsp; &nbsp;Linux设备模型使用了类似于面向对象的思想，由于C语言在语法上不支持面向对象，Linux内核使用了特殊的设计实现了面向对象。从我目前的理解来看，这样的设计似乎与C++语法中的面向对象有一些区别，例如，C++中对于是继承关系和包含关系描述的很清晰，通过不同的形式表现出来；但在Linux内核中继承与包含都是通过内嵌相关的数据来实现的。在我一开始阅读Linux内核设备模型相关内容时，总想着通过将其用类似C++中的描述进行理解，这样越想越糊涂。并且由于源码的结构复杂，LKD和LDD中也没有很通俗的将Linux设备模型描述出来，所以理解Linux设备模型时是有一些难度的。


&nbsp; &nbsp; &nbsp; &nbsp;目前我所理解的Linux设备模型还是比较浅显的，可能其中还有不正确的地方。一方面是读过的代码很少，另一方面使用设备模型写过的驱动更少，仅仅是用平台总线为开发板写了led的驱动。之后还需要多读源码多写驱动，才能真正明白Linux设备驱动模型。

